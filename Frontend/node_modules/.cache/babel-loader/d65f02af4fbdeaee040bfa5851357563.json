{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { polyfill } from 'react-lifecycles-compat';\nimport classNames from 'classnames';\nimport { ConfigConsumer } from '../config-provider';\n\nvar AnchorLink = /*#__PURE__*/function (_React$Component) {\n  _inherits(AnchorLink, _React$Component);\n\n  function AnchorLink() {\n    var _this;\n\n    _classCallCheck(this, AnchorLink);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnchorLink).apply(this, arguments));\n\n    _this.handleClick = function (e) {\n      var _this$context$antAnch = _this.context.antAnchor,\n          scrollTo = _this$context$antAnch.scrollTo,\n          onClick = _this$context$antAnch.onClick;\n      var _this$props = _this.props,\n          href = _this$props.href,\n          title = _this$props.title;\n\n      if (onClick) {\n        onClick(e, {\n          title: title,\n          href: href\n        });\n      }\n\n      scrollTo(href);\n    };\n\n    _this.renderAnchorLink = function (_ref) {\n      var getPrefixCls = _ref.getPrefixCls;\n      var _this$props2 = _this.props,\n          customizePrefixCls = _this$props2.prefixCls,\n          href = _this$props2.href,\n          title = _this$props2.title,\n          children = _this$props2.children,\n          className = _this$props2.className,\n          target = _this$props2.target;\n      var prefixCls = getPrefixCls('anchor', customizePrefixCls);\n      var active = _this.context.antAnchor.activeLink === href;\n      var wrapperClassName = classNames(className, \"\".concat(prefixCls, \"-link\"), _defineProperty({}, \"\".concat(prefixCls, \"-link-active\"), active));\n      var titleClassName = classNames(\"\".concat(prefixCls, \"-link-title\"), _defineProperty({}, \"\".concat(prefixCls, \"-link-title-active\"), active));\n      return React.createElement(\"div\", {\n        className: wrapperClassName\n      }, React.createElement(\"a\", {\n        className: titleClassName,\n        href: href,\n        title: typeof title === 'string' ? title : '',\n        target: target,\n        onClick: _this.handleClick\n      }, title), children);\n    };\n\n    return _this;\n  }\n\n  _createClass(AnchorLink, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.context.antAnchor.registerLink(this.props.href);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_ref2) {\n      var prevHref = _ref2.href;\n      var href = this.props.href;\n\n      if (prevHref !== href) {\n        this.context.antAnchor.unregisterLink(prevHref);\n        this.context.antAnchor.registerLink(href);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.context.antAnchor.unregisterLink(this.props.href);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(ConfigConsumer, null, this.renderAnchorLink);\n    }\n  }]);\n\n  return AnchorLink;\n}(React.Component);\n\nAnchorLink.defaultProps = {\n  href: '#'\n};\nAnchorLink.contextTypes = {\n  antAnchor: PropTypes.object\n};\npolyfill(AnchorLink);\nexport default AnchorLink;","map":{"version":3,"mappings":"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","names":["React","PropTypes","polyfill","classNames","ConfigConsumer","AnchorLink","_classCallCheck","_this","arguments","handleClick","e","context","antAnchor","scrollTo","onClick","props","href","title","renderAnchorLink","getPrefixCls","customizePrefixCls","prefixCls","children","className","target","active","activeLink","wrapperClassName","titleClassName","registerLink","prevHref","unregisterLink","Component","defaultProps","contextTypes","object"],"sources":["anchor/AnchorLink.jsx"],"sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { polyfill } from 'react-lifecycles-compat';\nimport classNames from 'classnames';\nimport { ConfigConsumer } from '../config-provider';\nclass AnchorLink extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.handleClick = (e) => {\n            const { scrollTo, onClick } = this.context.antAnchor;\n            const { href, title } = this.props;\n            if (onClick) {\n                onClick(e, { title, href });\n            }\n            scrollTo(href);\n        };\n        this.renderAnchorLink = ({ getPrefixCls }) => {\n            const { prefixCls: customizePrefixCls, href, title, children, className, target } = this.props;\n            const prefixCls = getPrefixCls('anchor', customizePrefixCls);\n            const active = this.context.antAnchor.activeLink === href;\n            const wrapperClassName = classNames(className, `${prefixCls}-link`, {\n                [`${prefixCls}-link-active`]: active,\n            });\n            const titleClassName = classNames(`${prefixCls}-link-title`, {\n                [`${prefixCls}-link-title-active`]: active,\n            });\n            return (<div className={wrapperClassName}>\n        <a className={titleClassName} href={href} title={typeof title === 'string' ? title : ''} target={target} onClick={this.handleClick}>\n          {title}\n        </a>\n        {children}\n      </div>);\n        };\n    }\n    componentDidMount() {\n        this.context.antAnchor.registerLink(this.props.href);\n    }\n    componentDidUpdate({ href: prevHref }) {\n        const { href } = this.props;\n        if (prevHref !== href) {\n            this.context.antAnchor.unregisterLink(prevHref);\n            this.context.antAnchor.registerLink(href);\n        }\n    }\n    componentWillUnmount() {\n        this.context.antAnchor.unregisterLink(this.props.href);\n    }\n    render() {\n        return <ConfigConsumer>{this.renderAnchorLink}</ConfigConsumer>;\n    }\n}\nAnchorLink.defaultProps = {\n    href: '#',\n};\nAnchorLink.contextTypes = {\n    antAnchor: PropTypes.object,\n};\npolyfill(AnchorLink);\nexport default AnchorLink;\n"]},"metadata":{},"sourceType":"module"}